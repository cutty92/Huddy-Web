import { LayoutData } from '@/types';
import { validateLayout } from './validation';

export interface ExportOptions {
  format: 'formatted' | 'minified' | 'with-comments';
  includeMetadata: boolean;
  validateBeforeExport: boolean;
}

export interface ImportResult {
  success: boolean;
  layout?: LayoutData;
  errors: string[];
  warnings: string[];
}

// Export layout to JSON string
export function exportLayout(layout: LayoutData, options: ExportOptions = {
  format: 'formatted',
  includeMetadata: true,
  validateBeforeExport: true
}): string {
  let exportData = { ...layout };

  // Add metadata if requested
  if (options.includeMetadata) {
    exportData = {
      ...exportData,
      metadata: {
        name: 'Hardware Monitor Layout',
        description: 'Generated by Hardware Monitor JSON Editor',
        author: 'JSON Editor',
        created: new Date().toISOString(),
        modified: new Date().toISOString(),
        tags: ['hardware', 'monitor', 'overlay'],
        compatibility: {
          minVersion: '1.0',
          maxVersion: '2.0'
        }
      }
    };
  }

  // Validate before export if requested
  if (options.validateBeforeExport) {
    const validation = validateLayout(layout);
    if (!validation.isValid) {
      throw new Error(`Layout validation failed: ${validation.errors.map(e => e.message).join(', ')}`);
    }
  }

  // Format JSON based on options
  switch (options.format) {
    case 'minified':
      return JSON.stringify(exportData);
    
    case 'with-comments':
      return addCommentsToJSON(exportData);
    
    case 'formatted':
    default:
      return JSON.stringify(exportData, null, 2);
  }
}

// Import layout from JSON string
export function importLayout(jsonString: string): ImportResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  try {
    // Parse JSON
    const layout = JSON.parse(jsonString) as LayoutData;

    // Validate layout
    const validation = validateLayout(layout);
    
    if (!validation.isValid) {
      errors.push(...validation.errors.map(e => e.message));
    }
    
    warnings.push(...validation.warnings.map(w => w.message));

    // Check for required fields
    if (!layout.version) {
      errors.push('Missing required field: version');
    }

    if (!layout.elements || !Array.isArray(layout.elements)) {
      errors.push('Missing or invalid elements array');
    }

    // Check for duplicate element IDs
    if (layout.elements) {
      const ids = layout.elements.map(el => el.id);
      const duplicates = ids.filter((id, index) => ids.indexOf(id) !== index);
      if (duplicates.length > 0) {
        errors.push(`Duplicate element IDs found: ${duplicates.join(', ')}`);
      }
    }

    return {
      success: errors.length === 0,
      layout: errors.length === 0 ? layout : undefined,
      errors,
      warnings
    };

  } catch (error) {
    return {
      success: false,
      errors: [`Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}`],
      warnings
    };
  }
}

// Add comments to JSON for better readability
function addCommentsToJSON(obj: any): string {
  // This is a simplified version - in practice, you'd need a more sophisticated approach
  // since JSON doesn't natively support comments
  let json = JSON.stringify(obj, null, 2);
  
  // Add some basic comments
  json = json.replace(
    /"version": "([^"]+)"/,
    '"version": "$1" // Schema version'
  );
  
  json = json.replace(
    /"elements": \[/,
    '"elements": [ // Array of visual elements'
  );
  
  json = json.replace(
    /"id": "([^"]+)"/,
    '"id": "$1" // Unique element identifier'
  );
  
  json = json.replace(
    /"sensor": "([^"]+)"/,
    '"sensor": "$1" // Hardware sensor binding'
  );
  
  return json;
}

// Download layout as file
export function downloadLayout(layout: LayoutData, filename: string = 'layout.json', options?: ExportOptions) {
  const json = exportLayout(layout, options);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  URL.revokeObjectURL(url);
}

// Load layout from file
export function loadLayoutFromFile(file: File): Promise<ImportResult> {
  return new Promise((resolve) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const json = e.target?.result as string;
      const result = importLayout(json);
      resolve(result);
    };
    
    reader.onerror = () => {
      resolve({
        success: false,
        errors: ['Failed to read file'],
        warnings: []
      });
    };
    
    reader.readAsText(file);
  });
}

// Validate file before import
export function validateFile(file: File): Promise<{ valid: boolean; errors: string[] }> {
  return new Promise((resolve) => {
    if (!file.name.endsWith('.json')) {
      resolve({
        valid: false,
        errors: ['File must be a JSON file']
      });
      return;
    }

    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      resolve({
        valid: false,
        errors: ['File size too large (max 10MB)']
      });
      return;
    }

    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const json = e.target?.result as string;
        const layout = JSON.parse(json);
        
        // Basic structure validation
        if (!layout.elements || !Array.isArray(layout.elements)) {
          resolve({
            valid: false,
            errors: ['Invalid layout structure: missing elements array']
          });
          return;
        }

        resolve({
          valid: true,
          errors: []
        });
      } catch (error) {
        resolve({
          valid: false,
          errors: [`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown error'}`]
        });
      }
    };
    
    reader.onerror = () => {
      resolve({
        valid: false,
        errors: ['Failed to read file']
      });
    };
    
    reader.readAsText(file);
  });
}
